# ... (بخش‌های اولیه کد شما بدون تغییر باقی می‌مانند) ...
import asyncio
import time
import uuid
import logging
import random
import os
from aiohttp import web
from telethon import TelegramClient, events, types
from telethon.tl.types import InputBotInlineResult, InputBotInlineMessageText
from telethon.errors.rpcerrorlist import MessageNotModifiedError

from tes.question import questions

# ثابت‌ها برای تنظیمات بازی
QUESTION_TIMEOUT_SECONDS = 10
WAIT_BETWEEN_QUESTIONS_SECONDS = 3
TOTAL_QUESTIONS = 10

logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')
logger = logging.getLogger(__name__)

API_ID = os.environ.get('API_ID', '3335796')
API_HASH = os.environ.get('API_HASH', '138b992a0e672e8346d8439c3f42ea78')
BOT_TOKEN = os.environ.get('BOT_TOKEN', '5002292255:AAGc9Lk0LXX1cjfERx6CnVye0A5EUNvgtzU')

app = TelegramClient("watermark_bot", api_id=API_ID, api_hash=API_HASH)

game_sessions = {}
# <<< تغییر کلیدی: به جای تایمرها، تسک اصلی بازی را نگه می‌داریم
active_game_tasks = {}

# ... (توابع کمکی health_check, get_players_text, get_initial_markup, edit_game_message بدون تغییر) ...

# <<< تغییر کلیدی: تابع لغو تسک اصلی بازی
def cancel_game_task(session_key):
    if session_key in active_game_tasks:
        task = active_game_tasks.pop(session_key)
        if not task.done():
            task.cancel()
        logger.info(f"TASK_CANCEL: Game loop task for session {session_key} was cancelled.")
        return True
    return False

# تابع پاک‌سازی جلسات قدیمی (با تابع لغو جدید)
async def cleanup_old_sessions():
    try:
        while True:
            await asyncio.sleep(600)
            expired_keys = [key for key, session in game_sessions.items() if time.time() - session.get("created_at", 0) > 1200]
            for key in expired_keys:
                logger.info(f"CLEANUP: Cleaning up expired session {key}")
                cancel_game_task(key) # <<< استفاده از تابع لغو جدید
                if key in game_sessions:
                    del game_sessions[key]
    except asyncio.CancelledError:
        logger.info("Cleanup task cancelled")
        raise

# ... (بقیه توابع کمکی مثل get_players_text, get_initial_markup, edit_game_message اینجا قرار می‌گیرند) ...
# ... (برای اختصار حذف شده‌اند، فرض می‌کنیم بدون تغییر هستند) ...


@app.on(events.CallbackQuery())
async def handle_buttons(event):
    data_parts = event.data.decode('utf-8').split('|')
    action = data_parts[0]
    session_key = data_parts[1] if len(data_parts) > 1 else None
    
    if not session_key or session_key not in game_sessions:
        await event.answer("این بازی منقضی شده یا دیگر وجود ندارد.", alert=True)
        return
        
    session = game_sessions[session_key]
    
    # ... (بخش im_in بدون تغییر) ...

    # <<< تغییر کلیدی: منطق شروع و لغو بازی
    elif action == "start_game":
        if event.sender_id != session.get("starter_id"):
            await event.answer("فقط شروع‌کننده می‌تواند بازی را استارت بزند!", alert=True)
            return
        if not session["players"]:
            await event.answer("هنوز هیچکس پایه نیست!", alert=True)
            return
        if session["started"]:
            await event.answer("بازی قبلاً شروع شده است!", alert=True)
            return
            
        await event.answer("🚀 بازی شروع می‌شود!")
        session["started"] = True
        
        # یک تسک واحد برای کل بازی ایجاد و ذخیره می‌کنیم
        game_task = asyncio.create_task(run_game_loop(app, session_key))
        active_game_tasks[session_key] = game_task
        logger.info(f"GAME_START: Game loop task created for session {session_key}.")

    elif action == "cancel_game":
        if event.sender_id != session.get("starter_id"):
            await event.answer("فقط شروع‌کننده می‌تواند بازی را لغو کند!", alert=True)
            return
        
        text_to_update = "❌ بازی توسط شروع‌کننده لغو شد."
        await edit_game_message(app, session, text_to_update, None)
        
        # تسک اصلی بازی را لغو می‌کنیم
        cancel_game_task(session_key)
        if session_key in game_sessions:
            del game_sessions[session_key]
        logger.info(f"SESSION_CANCEL: Session {session_key} was cancelled by starter.")

    elif action == "answer":
        # این تابع بدون تغییر کار می‌کند
        await handle_answer(app, event, session_key, data_parts[2])


# ... (تابع handle_answer بدون تغییر) ...
async def handle_answer(client, event, session_key, selected_option):
    session = game_sessions.get(session_key)
    if not session: return

    # ... (بقیه منطق handle_answer) ...
    # این تابع دیگر نیازی به تغییر ندارد چون به درستی `active_question` را چک می‌کند
    if not session.get("active_question"):
        await event.answer("زمان پاسخ به این سوال تمام شده است!", alert=True)
        return
    # ...


# ##################################################################
# ############## راه‌حل اصلی: حلقه مدیریت بازی #######################
# ##################################################################
async def run_game_loop(client, session_key):
    """
    این تابع کل جریان بازی را از سوال اول تا آخر در یک حلقه مدیریت می‌کند.
    جایگزین ask_question_in_chat و question_timeout می‌شود.
    """
    session = game_sessions.get(session_key)
    if not session:
        logger.error(f"GAME_LOOP: Session {session_key} not found at start. Aborting.")
        return

    try:
        # حلقه اصلی بازی برای پرسیدن سوالات
        while session["current_q_index"] < len(session["questions"]):
            session["responded_users"].clear()
            q_index = session["current_q_index"]
            q = session["questions"][q_index]

            # --- 1. نمایش سوال ---
            options_list = q["options"][:]
            random.shuffle(options_list)
            buttons = [types.KeyboardButtonCallback(text=opt, data=f"answer|{session_key}|{opt}".encode()) for opt in options_list]
            rows = [types.KeyboardButtonRow(buttons[i:i+2]) for i in range(0, len(buttons), 2)]
            markup = types.ReplyInlineMarkup(rows)

            question_text = (
                f"سوال {q_index + 1} از {len(session['questions'])}\n\n"
                f"❓ **{q['question']}**\n\n"
                f"{QUESTION_TIMEOUT_SECONDS} ثانیه فرصت پاسخگویی دارید..."
            )
            full_text = get_players_text(session) + "\n\n" + question_text
            
            session["active_question"] = True # <<< سوال فعال شد
            session["question_start_time"] = time.time()
            
            await edit_game_message(client, session, full_text, markup)
            logger.info(f"GAME_LOOP: Question {q_index + 1} displayed for session {session_key}.")

            # --- 2. انتظار برای تمام شدن زمان ---
            await asyncio.sleep(QUESTION_TIMEOUT_SECONDS)
            
            session["active_question"] = False # <<< زمان تمام شد، سوال غیرفعال شد
            logger.info(f"GAME_LOOP: Timeout for question {q_index + 1} in session {session_key}.")

            # --- 3. نمایش نتیجه سوال ---
            correct_answer = q["answer"]
            players_summary_text = get_players_text(session)
            timeout_text = (
                f"{players_summary_text}\n\n"
                f"⏰ زمان پاسخ تمام شد!\n"
                f"جواب صحیح: **{correct_answer}**\n\n"
                f"آماده برای سوال بعدی..."
            )
            await edit_game_message(client, session, timeout_text, None)

            # --- 4. حرکت به سوال بعدی ---
            session["current_q_index"] += 1
            if session["current_q_index"] < len(session["questions"]):
                await asyncio.sleep(WAIT_BETWEEN_QUESTIONS_SECONDS)
        
        # --- 5. پایان بازی و اعلام نتایج ---
        await announce_final_results(client, session_key)

    except asyncio.CancelledError:
        logger.info(f"GAME_LOOP: Game loop for session {session_key} was cancelled successfully.")
        # نیازی به کار خاصی نیست، تسک به درستی لغو شده
        
    except Exception as e:
        logger.error(f"GAME_LOOP_ERROR: Unexpected error in game loop for session {session_key}: {e}", exc_info=True)
        # در صورت بروز خطای پیش‌بینی نشده، جلسه را پاک کن
        if session_key in game_sessions:
            del game_sessions[session_key]
    
    finally:
        # اطمینان از حذف تسک از لیست فعال
        if session_key in active_game_tasks:
            del active_game_tasks[session_key]


async def announce_final_results(client, session_key):
    # این تابع تقریبا بدون تغییر باقی می‌ماند، فقط بخش پاکسازی آن دیگر لازم نیست
    session = game_sessions.get(session_key)
    if not session: return

    sorted_players = sorted(session["players"], key=lambda p: p['score'], reverse=True)
    final_text = "🏆 نتایج نهایی چالش 🏆\n\n"
    if sorted_players:
        for i, p in enumerate(sorted_players):
            emoji = "🥇" if i == 0 else "🥈" if i == 1 else "🥉" if i == 2 else "▫️"
            final_text += f"{emoji} {p['name']}: {p['score']} امتیاز\n"
    else:
        final_text += "هیچ بازیکنی در این دور شرکت نکرد."
    
    final_text += "\nبازی تمام شد! برای شروع یک بازی جدید، از دکمه زیر استفاده کنید."
    invite_button = types.KeyboardButtonRow([types.KeyboardButtonSwitchInline("👥 شروع یک بازی جدید", query="")])
    final_markup = types.ReplyInlineMarkup([invite_button])
    
    await edit_game_message(client, session, final_text, final_markup)
    
    # <<< تغییر کلیدی: پاکسازی نهایی جلسه در انتهای حلقه بازی انجام می‌شود
    if session_key in game_sessions:
        del game_sessions[session_key]
    logger.info(f"SESSION_END: Final results announced and session {session_key} cleaned up.")


# --- بخش اصلی اجرای ربات ---
# این بخش بدون تغییر باقی می‌ماند
async def main():
    # ...
    pass # فرض بر این است که این بخش صحیح است

if __name__ == "__main__":
    # ...
    pass # فرض بر این است که این بخش صحیح است
