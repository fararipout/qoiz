# ... (Ø¨Ø®Ø´â€ŒÙ‡Ø§ÛŒ Ø§ÙˆÙ„ÛŒÙ‡ Ú©Ø¯ Ø´Ù…Ø§ Ø¨Ø¯ÙˆÙ† ØªØºÛŒÛŒØ± Ø¨Ø§Ù‚ÛŒ Ù…ÛŒâ€ŒÙ…Ø§Ù†Ù†Ø¯) ...
import asyncio
import time
import uuid
import logging
import random
import os
from aiohttp import web
from telethon import TelegramClient, events, types
from telethon.tl.types import InputBotInlineResult, InputBotInlineMessageText
from telethon.errors.rpcerrorlist import MessageNotModifiedError

from tes.question import questions

# Ø«Ø§Ø¨Øªâ€ŒÙ‡Ø§ Ø¨Ø±Ø§ÛŒ ØªÙ†Ø¸ÛŒÙ…Ø§Øª Ø¨Ø§Ø²ÛŒ
QUESTION_TIMEOUT_SECONDS = 10
WAIT_BETWEEN_QUESTIONS_SECONDS = 3
TOTAL_QUESTIONS = 10

logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')
logger = logging.getLogger(__name__)

API_ID = os.environ.get('API_ID', '3335796')
API_HASH = os.environ.get('API_HASH', '138b992a0e672e8346d8439c3f42ea78')
BOT_TOKEN = os.environ.get('BOT_TOKEN', '5002292255:AAGc9Lk0LXX1cjfERx6CnVye0A5EUNvgtzU')

app = TelegramClient("watermark_bot", api_id=API_ID, api_hash=API_HASH)

game_sessions = {}
# <<< ØªØºÛŒÛŒØ± Ú©Ù„ÛŒØ¯ÛŒ: Ø¨Ù‡ Ø¬Ø§ÛŒ ØªØ§ÛŒÙ…Ø±Ù‡Ø§ØŒ ØªØ³Ú© Ø§ØµÙ„ÛŒ Ø¨Ø§Ø²ÛŒ Ø±Ø§ Ù†Ú¯Ù‡ Ù…ÛŒâ€ŒØ¯Ø§Ø±ÛŒÙ…
active_game_tasks = {}

# ... (ØªÙˆØ§Ø¨Ø¹ Ú©Ù…Ú©ÛŒ health_check, get_players_text, get_initial_markup, edit_game_message Ø¨Ø¯ÙˆÙ† ØªØºÛŒÛŒØ±) ...

# <<< ØªØºÛŒÛŒØ± Ú©Ù„ÛŒØ¯ÛŒ: ØªØ§Ø¨Ø¹ Ù„ØºÙˆ ØªØ³Ú© Ø§ØµÙ„ÛŒ Ø¨Ø§Ø²ÛŒ
def cancel_game_task(session_key):
    if session_key in active_game_tasks:
        task = active_game_tasks.pop(session_key)
        if not task.done():
            task.cancel()
        logger.info(f"TASK_CANCEL: Game loop task for session {session_key} was cancelled.")
        return True
    return False

# ØªØ§Ø¨Ø¹ Ù¾Ø§Ú©â€ŒØ³Ø§Ø²ÛŒ Ø¬Ù„Ø³Ø§Øª Ù‚Ø¯ÛŒÙ…ÛŒ (Ø¨Ø§ ØªØ§Ø¨Ø¹ Ù„ØºÙˆ Ø¬Ø¯ÛŒØ¯)
async def cleanup_old_sessions():
    try:
        while True:
            await asyncio.sleep(600)
            expired_keys = [key for key, session in game_sessions.items() if time.time() - session.get("created_at", 0) > 1200]
            for key in expired_keys:
                logger.info(f"CLEANUP: Cleaning up expired session {key}")
                cancel_game_task(key) # <<< Ø§Ø³ØªÙØ§Ø¯Ù‡ Ø§Ø² ØªØ§Ø¨Ø¹ Ù„ØºÙˆ Ø¬Ø¯ÛŒØ¯
                if key in game_sessions:
                    del game_sessions[key]
    except asyncio.CancelledError:
        logger.info("Cleanup task cancelled")
        raise

# ... (Ø¨Ù‚ÛŒÙ‡ ØªÙˆØ§Ø¨Ø¹ Ú©Ù…Ú©ÛŒ Ù…Ø«Ù„ get_players_text, get_initial_markup, edit_game_message Ø§ÛŒÙ†Ø¬Ø§ Ù‚Ø±Ø§Ø± Ù…ÛŒâ€ŒÚ¯ÛŒØ±Ù†Ø¯) ...
# ... (Ø¨Ø±Ø§ÛŒ Ø§Ø®ØªØµØ§Ø± Ø­Ø°Ù Ø´Ø¯Ù‡â€ŒØ§Ù†Ø¯ØŒ ÙØ±Ø¶ Ù…ÛŒâ€ŒÚ©Ù†ÛŒÙ… Ø¨Ø¯ÙˆÙ† ØªØºÛŒÛŒØ± Ù‡Ø³ØªÙ†Ø¯) ...


@app.on(events.CallbackQuery())
async def handle_buttons(event):
    data_parts = event.data.decode('utf-8').split('|')
    action = data_parts[0]
    session_key = data_parts[1] if len(data_parts) > 1 else None
    
    if not session_key or session_key not in game_sessions:
        await event.answer("Ø§ÛŒÙ† Ø¨Ø§Ø²ÛŒ Ù…Ù†Ù‚Ø¶ÛŒ Ø´Ø¯Ù‡ ÛŒØ§ Ø¯ÛŒÚ¯Ø± ÙˆØ¬ÙˆØ¯ Ù†Ø¯Ø§Ø±Ø¯.", alert=True)
        return
        
    session = game_sessions[session_key]
    
    # ... (Ø¨Ø®Ø´ im_in Ø¨Ø¯ÙˆÙ† ØªØºÛŒÛŒØ±) ...

    # <<< ØªØºÛŒÛŒØ± Ú©Ù„ÛŒØ¯ÛŒ: Ù…Ù†Ø·Ù‚ Ø´Ø±ÙˆØ¹ Ùˆ Ù„ØºÙˆ Ø¨Ø§Ø²ÛŒ
    elif action == "start_game":
        if event.sender_id != session.get("starter_id"):
            await event.answer("ÙÙ‚Ø· Ø´Ø±ÙˆØ¹â€ŒÚ©Ù†Ù†Ø¯Ù‡ Ù…ÛŒâ€ŒØªÙˆØ§Ù†Ø¯ Ø¨Ø§Ø²ÛŒ Ø±Ø§ Ø§Ø³ØªØ§Ø±Øª Ø¨Ø²Ù†Ø¯!", alert=True)
            return
        if not session["players"]:
            await event.answer("Ù‡Ù†ÙˆØ² Ù‡ÛŒÚ†Ú©Ø³ Ù¾Ø§ÛŒÙ‡ Ù†ÛŒØ³Øª!", alert=True)
            return
        if session["started"]:
            await event.answer("Ø¨Ø§Ø²ÛŒ Ù‚Ø¨Ù„Ø§Ù‹ Ø´Ø±ÙˆØ¹ Ø´Ø¯Ù‡ Ø§Ø³Øª!", alert=True)
            return
            
        await event.answer("ðŸš€ Ø¨Ø§Ø²ÛŒ Ø´Ø±ÙˆØ¹ Ù…ÛŒâ€ŒØ´ÙˆØ¯!")
        session["started"] = True
        
        # ÛŒÚ© ØªØ³Ú© ÙˆØ§Ø­Ø¯ Ø¨Ø±Ø§ÛŒ Ú©Ù„ Ø¨Ø§Ø²ÛŒ Ø§ÛŒØ¬Ø§Ø¯ Ùˆ Ø°Ø®ÛŒØ±Ù‡ Ù…ÛŒâ€ŒÚ©Ù†ÛŒÙ…
        game_task = asyncio.create_task(run_game_loop(app, session_key))
        active_game_tasks[session_key] = game_task
        logger.info(f"GAME_START: Game loop task created for session {session_key}.")

    elif action == "cancel_game":
        if event.sender_id != session.get("starter_id"):
            await event.answer("ÙÙ‚Ø· Ø´Ø±ÙˆØ¹â€ŒÚ©Ù†Ù†Ø¯Ù‡ Ù…ÛŒâ€ŒØªÙˆØ§Ù†Ø¯ Ø¨Ø§Ø²ÛŒ Ø±Ø§ Ù„ØºÙˆ Ú©Ù†Ø¯!", alert=True)
            return
        
        text_to_update = "âŒ Ø¨Ø§Ø²ÛŒ ØªÙˆØ³Ø· Ø´Ø±ÙˆØ¹â€ŒÚ©Ù†Ù†Ø¯Ù‡ Ù„ØºÙˆ Ø´Ø¯."
        await edit_game_message(app, session, text_to_update, None)
        
        # ØªØ³Ú© Ø§ØµÙ„ÛŒ Ø¨Ø§Ø²ÛŒ Ø±Ø§ Ù„ØºÙˆ Ù…ÛŒâ€ŒÚ©Ù†ÛŒÙ…
        cancel_game_task(session_key)
        if session_key in game_sessions:
            del game_sessions[session_key]
        logger.info(f"SESSION_CANCEL: Session {session_key} was cancelled by starter.")

    elif action == "answer":
        # Ø§ÛŒÙ† ØªØ§Ø¨Ø¹ Ø¨Ø¯ÙˆÙ† ØªØºÛŒÛŒØ± Ú©Ø§Ø± Ù…ÛŒâ€ŒÚ©Ù†Ø¯
        await handle_answer(app, event, session_key, data_parts[2])


# ... (ØªØ§Ø¨Ø¹ handle_answer Ø¨Ø¯ÙˆÙ† ØªØºÛŒÛŒØ±) ...
async def handle_answer(client, event, session_key, selected_option):
    session = game_sessions.get(session_key)
    if not session: return

    # ... (Ø¨Ù‚ÛŒÙ‡ Ù…Ù†Ø·Ù‚ handle_answer) ...
    # Ø§ÛŒÙ† ØªØ§Ø¨Ø¹ Ø¯ÛŒÚ¯Ø± Ù†ÛŒØ§Ø²ÛŒ Ø¨Ù‡ ØªØºÛŒÛŒØ± Ù†Ø¯Ø§Ø±Ø¯ Ú†ÙˆÙ† Ø¨Ù‡ Ø¯Ø±Ø³ØªÛŒ `active_question` Ø±Ø§ Ú†Ú© Ù…ÛŒâ€ŒÚ©Ù†Ø¯
    if not session.get("active_question"):
        await event.answer("Ø²Ù…Ø§Ù† Ù¾Ø§Ø³Ø® Ø¨Ù‡ Ø§ÛŒÙ† Ø³ÙˆØ§Ù„ ØªÙ…Ø§Ù… Ø´Ø¯Ù‡ Ø§Ø³Øª!", alert=True)
        return
    # ...


# ##################################################################
# ############## Ø±Ø§Ù‡â€ŒØ­Ù„ Ø§ØµÙ„ÛŒ: Ø­Ù„Ù‚Ù‡ Ù…Ø¯ÛŒØ±ÛŒØª Ø¨Ø§Ø²ÛŒ #######################
# ##################################################################
async def run_game_loop(client, session_key):
    """
    Ø§ÛŒÙ† ØªØ§Ø¨Ø¹ Ú©Ù„ Ø¬Ø±ÛŒØ§Ù† Ø¨Ø§Ø²ÛŒ Ø±Ø§ Ø§Ø² Ø³ÙˆØ§Ù„ Ø§ÙˆÙ„ ØªØ§ Ø¢Ø®Ø± Ø¯Ø± ÛŒÚ© Ø­Ù„Ù‚Ù‡ Ù…Ø¯ÛŒØ±ÛŒØª Ù…ÛŒâ€ŒÚ©Ù†Ø¯.
    Ø¬Ø§ÛŒÚ¯Ø²ÛŒÙ† ask_question_in_chat Ùˆ question_timeout Ù…ÛŒâ€ŒØ´ÙˆØ¯.
    """
    session = game_sessions.get(session_key)
    if not session:
        logger.error(f"GAME_LOOP: Session {session_key} not found at start. Aborting.")
        return

    try:
        # Ø­Ù„Ù‚Ù‡ Ø§ØµÙ„ÛŒ Ø¨Ø§Ø²ÛŒ Ø¨Ø±Ø§ÛŒ Ù¾Ø±Ø³ÛŒØ¯Ù† Ø³ÙˆØ§Ù„Ø§Øª
        while session["current_q_index"] < len(session["questions"]):
            session["responded_users"].clear()
            q_index = session["current_q_index"]
            q = session["questions"][q_index]

            # --- 1. Ù†Ù…Ø§ÛŒØ´ Ø³ÙˆØ§Ù„ ---
            options_list = q["options"][:]
            random.shuffle(options_list)
            buttons = [types.KeyboardButtonCallback(text=opt, data=f"answer|{session_key}|{opt}".encode()) for opt in options_list]
            rows = [types.KeyboardButtonRow(buttons[i:i+2]) for i in range(0, len(buttons), 2)]
            markup = types.ReplyInlineMarkup(rows)

            question_text = (
                f"Ø³ÙˆØ§Ù„ {q_index + 1} Ø§Ø² {len(session['questions'])}\n\n"
                f"â“ **{q['question']}**\n\n"
                f"{QUESTION_TIMEOUT_SECONDS} Ø«Ø§Ù†ÛŒÙ‡ ÙØ±ØµØª Ù¾Ø§Ø³Ø®Ú¯ÙˆÛŒÛŒ Ø¯Ø§Ø±ÛŒØ¯..."
            )
            full_text = get_players_text(session) + "\n\n" + question_text
            
            session["active_question"] = True # <<< Ø³ÙˆØ§Ù„ ÙØ¹Ø§Ù„ Ø´Ø¯
            session["question_start_time"] = time.time()
            
            await edit_game_message(client, session, full_text, markup)
            logger.info(f"GAME_LOOP: Question {q_index + 1} displayed for session {session_key}.")

            # --- 2. Ø§Ù†ØªØ¸Ø§Ø± Ø¨Ø±Ø§ÛŒ ØªÙ…Ø§Ù… Ø´Ø¯Ù† Ø²Ù…Ø§Ù† ---
            await asyncio.sleep(QUESTION_TIMEOUT_SECONDS)
            
            session["active_question"] = False # <<< Ø²Ù…Ø§Ù† ØªÙ…Ø§Ù… Ø´Ø¯ØŒ Ø³ÙˆØ§Ù„ ØºÛŒØ±ÙØ¹Ø§Ù„ Ø´Ø¯
            logger.info(f"GAME_LOOP: Timeout for question {q_index + 1} in session {session_key}.")

            # --- 3. Ù†Ù…Ø§ÛŒØ´ Ù†ØªÛŒØ¬Ù‡ Ø³ÙˆØ§Ù„ ---
            correct_answer = q["answer"]
            players_summary_text = get_players_text(session)
            timeout_text = (
                f"{players_summary_text}\n\n"
                f"â° Ø²Ù…Ø§Ù† Ù¾Ø§Ø³Ø® ØªÙ…Ø§Ù… Ø´Ø¯!\n"
                f"Ø¬ÙˆØ§Ø¨ ØµØ­ÛŒØ­: **{correct_answer}**\n\n"
                f"Ø¢Ù…Ø§Ø¯Ù‡ Ø¨Ø±Ø§ÛŒ Ø³ÙˆØ§Ù„ Ø¨Ø¹Ø¯ÛŒ..."
            )
            await edit_game_message(client, session, timeout_text, None)

            # --- 4. Ø­Ø±Ú©Øª Ø¨Ù‡ Ø³ÙˆØ§Ù„ Ø¨Ø¹Ø¯ÛŒ ---
            session["current_q_index"] += 1
            if session["current_q_index"] < len(session["questions"]):
                await asyncio.sleep(WAIT_BETWEEN_QUESTIONS_SECONDS)
        
        # --- 5. Ù¾Ø§ÛŒØ§Ù† Ø¨Ø§Ø²ÛŒ Ùˆ Ø§Ø¹Ù„Ø§Ù… Ù†ØªØ§ÛŒØ¬ ---
        await announce_final_results(client, session_key)

    except asyncio.CancelledError:
        logger.info(f"GAME_LOOP: Game loop for session {session_key} was cancelled successfully.")
        # Ù†ÛŒØ§Ø²ÛŒ Ø¨Ù‡ Ú©Ø§Ø± Ø®Ø§ØµÛŒ Ù†ÛŒØ³ØªØŒ ØªØ³Ú© Ø¨Ù‡ Ø¯Ø±Ø³ØªÛŒ Ù„ØºÙˆ Ø´Ø¯Ù‡
        
    except Exception as e:
        logger.error(f"GAME_LOOP_ERROR: Unexpected error in game loop for session {session_key}: {e}", exc_info=True)
        # Ø¯Ø± ØµÙˆØ±Øª Ø¨Ø±ÙˆØ² Ø®Ø·Ø§ÛŒ Ù¾ÛŒØ´â€ŒØ¨ÛŒÙ†ÛŒ Ù†Ø´Ø¯Ù‡ØŒ Ø¬Ù„Ø³Ù‡ Ø±Ø§ Ù¾Ø§Ú© Ú©Ù†
        if session_key in game_sessions:
            del game_sessions[session_key]
    
    finally:
        # Ø§Ø·Ù…ÛŒÙ†Ø§Ù† Ø§Ø² Ø­Ø°Ù ØªØ³Ú© Ø§Ø² Ù„ÛŒØ³Øª ÙØ¹Ø§Ù„
        if session_key in active_game_tasks:
            del active_game_tasks[session_key]


async def announce_final_results(client, session_key):
    # Ø§ÛŒÙ† ØªØ§Ø¨Ø¹ ØªÙ‚Ø±ÛŒØ¨Ø§ Ø¨Ø¯ÙˆÙ† ØªØºÛŒÛŒØ± Ø¨Ø§Ù‚ÛŒ Ù…ÛŒâ€ŒÙ…Ø§Ù†Ø¯ØŒ ÙÙ‚Ø· Ø¨Ø®Ø´ Ù¾Ø§Ú©Ø³Ø§Ø²ÛŒ Ø¢Ù† Ø¯ÛŒÚ¯Ø± Ù„Ø§Ø²Ù… Ù†ÛŒØ³Øª
    session = game_sessions.get(session_key)
    if not session: return

    sorted_players = sorted(session["players"], key=lambda p: p['score'], reverse=True)
    final_text = "ðŸ† Ù†ØªØ§ÛŒØ¬ Ù†Ù‡Ø§ÛŒÛŒ Ú†Ø§Ù„Ø´ ðŸ†\n\n"
    if sorted_players:
        for i, p in enumerate(sorted_players):
            emoji = "ðŸ¥‡" if i == 0 else "ðŸ¥ˆ" if i == 1 else "ðŸ¥‰" if i == 2 else "â–«ï¸"
            final_text += f"{emoji} {p['name']}: {p['score']} Ø§Ù…ØªÛŒØ§Ø²\n"
    else:
        final_text += "Ù‡ÛŒÚ† Ø¨Ø§Ø²ÛŒÚ©Ù†ÛŒ Ø¯Ø± Ø§ÛŒÙ† Ø¯ÙˆØ± Ø´Ø±Ú©Øª Ù†Ú©Ø±Ø¯."
    
    final_text += "\nØ¨Ø§Ø²ÛŒ ØªÙ…Ø§Ù… Ø´Ø¯! Ø¨Ø±Ø§ÛŒ Ø´Ø±ÙˆØ¹ ÛŒÚ© Ø¨Ø§Ø²ÛŒ Ø¬Ø¯ÛŒØ¯ØŒ Ø§Ø² Ø¯Ú©Ù…Ù‡ Ø²ÛŒØ± Ø§Ø³ØªÙØ§Ø¯Ù‡ Ú©Ù†ÛŒØ¯."
    invite_button = types.KeyboardButtonRow([types.KeyboardButtonSwitchInline("ðŸ‘¥ Ø´Ø±ÙˆØ¹ ÛŒÚ© Ø¨Ø§Ø²ÛŒ Ø¬Ø¯ÛŒØ¯", query="")])
    final_markup = types.ReplyInlineMarkup([invite_button])
    
    await edit_game_message(client, session, final_text, final_markup)
    
    # <<< ØªØºÛŒÛŒØ± Ú©Ù„ÛŒØ¯ÛŒ: Ù¾Ø§Ú©Ø³Ø§Ø²ÛŒ Ù†Ù‡Ø§ÛŒÛŒ Ø¬Ù„Ø³Ù‡ Ø¯Ø± Ø§Ù†ØªÙ‡Ø§ÛŒ Ø­Ù„Ù‚Ù‡ Ø¨Ø§Ø²ÛŒ Ø§Ù†Ø¬Ø§Ù… Ù…ÛŒâ€ŒØ´ÙˆØ¯
    if session_key in game_sessions:
        del game_sessions[session_key]
    logger.info(f"SESSION_END: Final results announced and session {session_key} cleaned up.")


# --- Ø¨Ø®Ø´ Ø§ØµÙ„ÛŒ Ø§Ø¬Ø±Ø§ÛŒ Ø±Ø¨Ø§Øª ---
# Ø§ÛŒÙ† Ø¨Ø®Ø´ Ø¨Ø¯ÙˆÙ† ØªØºÛŒÛŒØ± Ø¨Ø§Ù‚ÛŒ Ù…ÛŒâ€ŒÙ…Ø§Ù†Ø¯
async def main():
    # ...
    pass # ÙØ±Ø¶ Ø¨Ø± Ø§ÛŒÙ† Ø§Ø³Øª Ú©Ù‡ Ø§ÛŒÙ† Ø¨Ø®Ø´ ØµØ­ÛŒØ­ Ø§Ø³Øª

if __name__ == "__main__":
    # ...
    pass # ÙØ±Ø¶ Ø¨Ø± Ø§ÛŒÙ† Ø§Ø³Øª Ú©Ù‡ Ø§ÛŒÙ† Ø¨Ø®Ø´ ØµØ­ÛŒØ­ Ø§Ø³Øª
